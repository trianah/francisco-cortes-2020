{"version":3,"sources":["webpack:///./behaviours/FitText.js","webpack:////Users/triana/projects/francisco-cortes-2020/node_modules/fitty/dist/fitty.module.js"],"names":["FitText","fitty","minSize","maxSize","Object","defineProperty","exports","value","_extends","assign","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","default","w","toArray","nl","slice","DrawState","fitties","redrawFrame","requestRedraw","cancelAnimationFrame","requestAnimationFrame","redraw","filter","f","dirty","active","redrawAll","type","forEach","styleComputed","computeStyle","shouldPreStyle","applyStyle","fittiesToRedraw","shouldRedraw","calculateStyles","markAsClean","dispatchFitEvent","availableWidth","element","parentNode","clientWidth","currentWidth","scrollWidth","previousFontSize","currentFontSize","Math","min","max","whiteSpace","multiLine","style","getComputedStyle","parseInt","getPropertyValue","display","preStyle","preStyleTestCompleted","test","originalStyle","getAttribute","cssText","dispatchEvent","CustomEvent","detail","oldValue","newValue","scaleFactor","fit","destroy","_","observeMutations","observer","disconnect","subscribe","unsubscribe","MutationObserver","observe","defaultOptions","subtree","childList","characterData","resizeDebounce","onWindowResized","clearTimeout","setTimeout","observeWindowDelay","events","set","enabled","method","e","observeWindow","fitAll","fittyCreate","elements","options","fittyOptions","publicFitties","map","newbie","push","init","unfreeze","freeze","undefined","document","querySelectorAll","window"],"mappings":"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","file":"1.bundle.1592122438276.js","sourcesContent":["import fitty from \"fitty\";\n\nfunction FitText() {\n  fitty(\"[data-fit]\", {\n    minSize: 12,\n    maxSize: 300\n  });\n}\n\nexport default FitText;\n\n\nif (module.hot) {module.hot.accept(function(err) {\nif (err) {\nconsole.error(err);\n}\n});\n}\n","/*\n * fitty v2.3.0 - Snugly resizes text to fit its parent container\n * Copyright (c) 2020 Rik Schennink <rik@pqina.nl> (https://pqina.nl/)\n */\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nexports.default = function (w) {\n\n  // no window, early exit\n  if (!w) return;\n\n  // node list to array helper method\n  var toArray = function toArray(nl) {\n    return [].slice.call(nl);\n  };\n\n  // states\n  var DrawState = {\n    IDLE: 0,\n    DIRTY_CONTENT: 1,\n    DIRTY_LAYOUT: 2,\n    DIRTY: 3\n  };\n\n  // all active fitty elements\n  var fitties = [];\n\n  // group all redraw calls till next frame, we cancel each frame request when a new one comes in. If no support for request animation frame, this is an empty function and supports for fitty stops.\n  var redrawFrame = null;\n  var requestRedraw = 'requestAnimationFrame' in w ? function () {\n    w.cancelAnimationFrame(redrawFrame);\n    redrawFrame = w.requestAnimationFrame(function () {\n      return redraw(fitties.filter(function (f) {\n        return f.dirty && f.active;\n      }));\n    });\n  } : function () {};\n\n  // sets all fitties to dirty so they are redrawn on the next redraw loop, then calls redraw\n  var redrawAll = function redrawAll(type) {\n    return function () {\n      fitties.forEach(function (f) {\n        return f.dirty = type;\n      });\n      requestRedraw();\n    };\n  };\n\n  // redraws fitties so they nicely fit their parent container\n  var redraw = function redraw(fitties) {\n\n    // getting info from the DOM at this point should not trigger a reflow, let's gather as much intel as possible before triggering a reflow\n\n    // check if styles of all fitties have been computed\n    fitties.filter(function (f) {\n      return !f.styleComputed;\n    }).forEach(function (f) {\n      f.styleComputed = computeStyle(f);\n    });\n\n    // restyle elements that require pre-styling, this triggers a reflow, please try to prevent by adding CSS rules (see docs)\n    fitties.filter(shouldPreStyle).forEach(applyStyle);\n\n    // we now determine which fitties should be redrawn\n    var fittiesToRedraw = fitties.filter(shouldRedraw);\n\n    // we calculate final styles for these fitties\n    fittiesToRedraw.forEach(calculateStyles);\n\n    // now we apply the calculated styles from our previous loop\n    fittiesToRedraw.forEach(function (f) {\n      applyStyle(f);\n      markAsClean(f);\n    });\n\n    // now we dispatch events for all restyled fitties\n    fittiesToRedraw.forEach(dispatchFitEvent);\n  };\n\n  var markAsClean = function markAsClean(f) {\n    return f.dirty = DrawState.IDLE;\n  };\n\n  var calculateStyles = function calculateStyles(f) {\n\n    // get available width from parent node\n    f.availableWidth = f.element.parentNode.clientWidth;\n\n    // the space our target element uses\n    f.currentWidth = f.element.scrollWidth;\n\n    // remember current font size\n    f.previousFontSize = f.currentFontSize;\n\n    // let's calculate the new font size\n    f.currentFontSize = Math.min(Math.max(f.minSize, f.availableWidth / f.currentWidth * f.previousFontSize), f.maxSize);\n\n    // if allows wrapping, only wrap when at minimum font size (otherwise would break container)\n    f.whiteSpace = f.multiLine && f.currentFontSize === f.minSize ? 'normal' : 'nowrap';\n  };\n\n  // should always redraw if is not dirty layout, if is dirty layout, only redraw if size has changed\n  var shouldRedraw = function shouldRedraw(f) {\n    return f.dirty !== DrawState.DIRTY_LAYOUT || f.dirty === DrawState.DIRTY_LAYOUT && f.element.parentNode.clientWidth !== f.availableWidth;\n  };\n\n  // every fitty element is tested for invalid styles\n  var computeStyle = function computeStyle(f) {\n\n    // get style properties\n    var style = w.getComputedStyle(f.element, null);\n\n    // get current font size in pixels (if we already calculated it, use the calculated version)\n    f.currentFontSize = parseInt(style.getPropertyValue('font-size'), 10);\n\n    // get display type and wrap mode\n    f.display = style.getPropertyValue('display');\n    f.whiteSpace = style.getPropertyValue('white-space');\n  };\n\n  // determines if this fitty requires initial styling, can be prevented by applying correct styles through CSS\n  var shouldPreStyle = function shouldPreStyle(f) {\n\n    var preStyle = false;\n\n    // if we already tested for prestyling we don't have to do it again\n    if (f.preStyleTestCompleted) return false;\n\n    // should have an inline style, if not, apply\n    if (!/inline-/.test(f.display)) {\n      preStyle = true;\n      f.display = 'inline-block';\n    }\n\n    // to correctly calculate dimensions the element should have whiteSpace set to nowrap\n    if (f.whiteSpace !== 'nowrap') {\n      preStyle = true;\n      f.whiteSpace = 'nowrap';\n    }\n\n    // we don't have to do this twice\n    f.preStyleTestCompleted = true;\n\n    return preStyle;\n  };\n\n  // apply styles to single fitty\n  var applyStyle = function applyStyle(f) {\n\n    // remember original style, we need this to restore the fitty style when unsubscribing\n    if (!f.originalStyle) f.originalStyle = f.element.getAttribute('style') || '';\n\n    // set the new style to the original style plus the fitty styles\n    f.element.style.cssText = f.originalStyle + ';white-space:' + f.whiteSpace + ';display:' + f.display + ';font-size:' + f.currentFontSize + 'px';\n  };\n\n  // dispatch a fit event on a fitty\n  var dispatchFitEvent = function dispatchFitEvent(f) {\n    f.element.dispatchEvent(new CustomEvent('fit', {\n      detail: {\n        oldValue: f.previousFontSize,\n        newValue: f.currentFontSize,\n        scaleFactor: f.currentFontSize / f.previousFontSize\n      }\n    }));\n  };\n\n  // fit method, marks the fitty as dirty and requests a redraw (this will also redraw any other fitty marked as dirty)\n  var fit = function fit(f, type) {\n    return function () {\n      f.dirty = type;\n      if (!f.active) return;\n      requestRedraw();\n    };\n  };\n\n  var init = function init(f) {\n\n    // should we observe DOM mutations\n    observeMutations(f);\n\n    // this is a new fitty so we need to validate if it's styles are in order\n    f.newbie = true;\n\n    // because it's a new fitty it should also be dirty, we want it to redraw on the first loop\n    f.dirty = true;\n\n    // we want to be able to update this fitty\n    fitties.push(f);\n  };\n\n  var destroy = function destroy(f) {\n    return function () {\n\n      // remove from fitties array\n      fitties = fitties.filter(function (_) {\n        return _.element !== f.element;\n      });\n\n      // stop observing DOM\n      if (f.observeMutations) f.observer.disconnect();\n\n      // reset font size to inherited size\n      f.element.style.cssText = f.originalStyle;\n    };\n  };\n\n  // add a new fitty, does not redraw said fitty\n  var subscribe = function subscribe(f) {\n    return function () {\n      if (f.active) return;\n      f.active = true;\n      requestRedraw();\n    };\n  };\n\n  // remove an existing fitty\n  var unsubscribe = function unsubscribe(f) {\n    return function () {\n      return f.active = false;\n    };\n  };\n\n  var observeMutations = function observeMutations(f) {\n\n    // no observing?\n    if (!f.observeMutations) return;\n\n    // start observing mutations\n    f.observer = new MutationObserver(fit(f, DrawState.DIRTY_CONTENT));\n\n    // start observing\n    f.observer.observe(f.element, f.observeMutations);\n  };\n\n  // default mutation observer settings\n  var mutationObserverDefaultSetting = {\n    subtree: true,\n    childList: true,\n    characterData: true\n  };\n\n  // default fitty options\n  var defaultOptions = {\n    minSize: 16,\n    maxSize: 512,\n    multiLine: true,\n    observeMutations: 'MutationObserver' in w ? mutationObserverDefaultSetting : false\n  };\n\n  // array of elements in, fitty instances out\n  function fittyCreate(elements, options) {\n\n    // set options object\n    var fittyOptions = _extends({}, defaultOptions, options);\n\n    // create fitties\n    var publicFitties = elements.map(function (element) {\n\n      // create fitty instance\n      var f = _extends({}, fittyOptions, {\n\n        // internal options for this fitty\n        element: element,\n        active: true\n      });\n\n      // initialise this fitty\n      init(f);\n\n      // expose API\n      return {\n        element: element,\n        fit: fit(f, DrawState.DIRTY),\n        unfreeze: subscribe(f),\n        freeze: unsubscribe(f),\n        unsubscribe: destroy(f)\n      };\n    });\n\n    // call redraw on newly initiated fitties\n    requestRedraw();\n\n    // expose fitties\n    return publicFitties;\n  }\n\n  // fitty creation function\n  function fitty(target) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n\n    // if target is a string\n    return typeof target === 'string' ?\n\n    // treat it as a querySelector\n    fittyCreate(toArray(document.querySelectorAll(target)), options) :\n\n    // create single fitty\n    fittyCreate([target], options)[0];\n  }\n\n  // handles viewport changes, redraws all fitties, but only does so after a timeout\n  var resizeDebounce = null;\n  var onWindowResized = function onWindowResized() {\n    w.clearTimeout(resizeDebounce);\n    resizeDebounce = w.setTimeout(redrawAll(DrawState.DIRTY_LAYOUT), fitty.observeWindowDelay);\n  };\n\n  // define observe window property, so when we set it to true or false events are automatically added and removed\n  var events = ['resize', 'orientationchange'];\n  Object.defineProperty(fitty, 'observeWindow', {\n    set: function set(enabled) {\n      var method = (enabled ? 'add' : 'remove') + 'EventListener';\n      events.forEach(function (e) {\n        w[method](e, onWindowResized);\n      });\n    }\n  });\n\n  // fitty global properties (by setting observeWindow to true the events above get added)\n  fitty.observeWindow = true;\n  fitty.observeWindowDelay = 100;\n\n  // public fit all method, will force redraw no matter what\n  fitty.fitAll = redrawAll(DrawState.DIRTY);\n\n  // export our fitty function, we don't want to keep it to our selves\n  return fitty;\n}(typeof window === 'undefined' ? null : window);"],"sourceRoot":""}